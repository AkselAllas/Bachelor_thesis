#!/usr/bin/env python
# coding: utf-8

import numpy as numpy
import sys
import matplotlib
import matplotlib.pyplot as plt
import numpy as np

from sklearn import svm, datasets
from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
from sklearn.utils.multiclass import unique_labels

from get_fig_data import *
sys.path.append("..")

from s2_preprocessor import *
from plotter import *

s2_preprocessor = s2_preprocessor(
    input_dimension=5120, #5120
    label_dir='../Label_tifs',
    data_dir='../Data',
    input_data_dir='../Input_data',
    region_of_interest_shapefile='../ROI/ROI.shp',
    window_dimension=8,
    tile_dimension=512,
    nb_images=5,
    nb_bands=22,
    nb_steps=8, #This is unused!! #nb_steps defines how many parts the tile will be split into for training
    rotation_augmentation=0,
    flipping_augmentation=0
)
plotter = plotter(s2_preprocessor, cmap='tab10')

def plot_confusion_matrix(y_true, y_pred, classes,
                          normalize=False,
                          title=None,
                          cmap=plt.cm.Blues):
    """
    This function prints and plots the confusion matrix.
    Normalization can be applied by setting `normalize=True`.
    """
    if not title:
        if normalize:
            title = 'Normalized confusion matrix'
        else:
            title = 'Confusion matrix, without normalization'

    # Compute confusion matrix
    cm = confusion_matrix(y_true, y_pred)
    # Only use the labels that appear in the data
    #classes = classes[unique_labels(y_true, y_pred)]
    classes = classes[unique_labels(y_pred)]
    if normalize:
        cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
        print("Normalized confusion matrix")
    else:
        print('Confusion matrix, without normalization')

    print(cm)

    fig, ax = plt.subplots()
    im = ax.imshow(cm, interpolation='nearest', cmap=cmap)
    ax.figure.colorbar(im, ax=ax)
    # We want to show all ticks...

    #ax.set(xticks=np.arange(cm.shape[1]),
    #       yticks=np.arange(cm.shape[0]),

    #print(cm[20])
    #print(cm.shape[0])
    #input("Press Enter to continue...")
    
    classes_cm_index = np.zeros((len(classes)))
    for i in np.arange(len(classes)):
        classes_cm_index[i] = np.where(classes==classes[i])[0] 
    print(classes_cm_index)
    input("Press Enter to continue...")

    ax.set(xticks=np.arange(len(classes)),
           yticks=np.arange(len(classes)),
           # ... and label them with the respective list entries
           xticklabels=classes, yticklabels=classes,
           title=title,
           ylabel='True label',
           xlabel='Predicted label')

    # Rotate the tick labels and set their alignment.
    plt.setp(ax.get_xticklabels(), rotation=45, ha="right",
             rotation_mode="anchor")

    # Loop over data dimensions and create text annotations.
    fmt = '.2f' if normalize else 'd'
    thresh = cm.max() / 2.
    for i in classes_cm_index:
        for j in classes_cm_index:
            ax.text(j, i, format(cm[i, j], fmt),
                    ha="center", va="center",
                    color="white" if cm[i, j] > thresh else "black")
    fig.tight_layout()
    return ax


#class_names = np.array([
#"Mitte-põllukultuu"
#,"Aedmaasikas"
#,"Astelpaju"
#,"Heintaimed, kõrrelise"
#,"Heintaimed, liblikõielise"
#,"Kaer"
#,"Kanep"
#,"Karjatamine väljaspool põllumajanduslik maad"
#,"Kartul"
#,"Mais"
#,"Mustkesa"
#,"Muu"
#,"Põldhernes"
#,"Põlduba"
#,"Peakapsas"
#,"Porgand"
#,"Punapeet"
#,"Rukis"
#,"Sööti jäetud maa"
#,"Suvinisu ja speltanisu"
#,"Suvioder"
#,"Suviraps ja -rüps"
#,"Suvitritikale"
#,"Talinisu"
#,"Talioder"
#,"Taliraps ja -rüps"
#,"Talitritikale"
#,"Tatar"
#])

classes=np.array(range(0,28))
#print(type(classes[0]))

Y_ground_truth, Y_predictions = get_fig_data("v47","0")
#plt.imshow(Y_ground_truth)
#plt.show()
#input("Press Enter to continue...")

#Y_pred  = np.zeros((512*512))
#for i in range(int(512)):
#    for j in range(512):
#            Y_pred[512*i+j] = Y_predictions[i][j]
#
#Y_true  = np.zeros((512*512))
#for i in range(int(512)):
#    for j in range(512):
#            Y_true[512*i+j] = Y_ground_truth[i][j]

#print(labels_map.shape)
#
#plt.imshow(labels_map)
#plt.show()
#input("Press Enter to continue...")
#
Y_true = np.reshape(Y_ground_truth,(512*512)).astype(int)
Y_pred = np.reshape(Y_predictions, (512*512)).astype(int)

#plotter.plot_labels(Y_true)
#plotter.plot_labels(Y_pred)

#print(type(Y_true[0]))
#print(Y_pred[0])

plt.show(plot_confusion_matrix(Y_true,Y_pred,classes,False))
